\documentclass[
	% -- opções da classe memoir --
	12pt,				% tamanho da fonte
	openright,			% capítulos começam em pág ímpar (insere página vazia caso preciso)
	oneside,			% para impressão em frente e verso. Oposto a oneside
	a4paper,			% tamanho do papel.
	% -- opções da classe abntex2 --
	chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
	%subsection=TITLE,% títulos de subseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	french,				% idioma adicional para hifenização
	spanish,			% idioma adicional para hifenização
	brazil				% o último idioma é o principal do documento
	]{abntex2}
% ---
% Pacotes básicos 
% ---
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage{mathptmx}			% Usa a fonte Times New Roman
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{lastpage}			% Usado pela Ficha catalográfica
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{subcaption}				% Inclusão de gráficos lado a lado
\usepackage{microtype} 			% para melhorias de justificação
\usepackage{tabularx,ragged2e}	% Para inserir tabelas
\usepackage{multirow}			% Para mesclar células
\usepackage[dvipsnames,table,xcdraw]{xcolor}		% Permite adicionar cores nas linhas de tabelas
\usepackage{fancyvrb}			% Permite adicionar arquivos de texto
\usepackage[portuguese, ruled, linesnumbered]{algorithm2e} % Uso de algoritmos
\usepackage{amsfonts}			% Permite usar notação de conjuntos
\usepackage{amsmath}			% Permite citar equações
\usepackage{amsthm}				% Permite criar teoremas e experimentos
\usepackage[font={bf, small}, labelsep=endash, labelfont=bf]{caption}	% Faz legenda de figuras ficarem em negrito
\usepackage{cancel}				% Permite fazer expressão tendendo a zero
\usepackage{epstopdf}			% Converte eps para pdf
\usepackage[final]{pdfpages}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{float}

\usepackage{listings} % Para incluir código Python
\usepackage{geometry} % Para ajustar as margens
\usepackage{xcolor}


\geometry{margin=1in}

\newcolumntype{L}{>{\RaggedRight\arraybackslash}X}
% ---
% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}				% para geração de dummy text
% ---
% ---
% Pacotes de citações
% ---
%\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[alf, abnt-emphasize=bf]{abntex2cite}	% Citações padrão ABNT
% ---
% Customizações para o layout da UFPA
% ---
\usepackage{modelo-ufpa/ufpa}
% Muda o título de lista de ilustrações para lista de figuras
\addto\captionsbrazil{%
  \renewcommand{\listfigurename}%
    {Lista de Ilustrações}%
	\renewcommand{\listtablename}%
    {Lista de Tabelas}%
}
% Permite utilizar figuras sem precisar colocar o caminho absoluto
\graphicspath{{imagens/}}
% Define o ambiente de experimentos
\theoremstyle{definition}
\newtheorem{experimento}{Experimento}[section]
\newcommand{\experimentoautorefname}{Experimento}


% --------------------------------------------------------------
% Informações do TRABALHO
% --------------------------------------------------------------
\universidade{UNIVERSIDADE FEDERAL DO PARÁ}
\instituto{INSTITUTO DE TECNOLOGIA}
\faculdade{FACULDADE DE COMPUTAÇÃO E TELECOMUNICAÇÕES}
%\curso{CURSO DE BACHARELADO EM SISTEMAS DE INFORMAÇÃO}
\titulo{RELATÓRIO DE SISTEMAS OPERACIONAIS}
\autor{
%\begin{tabular}{l l}
    DAVID PINHEIRO DE SOUSA - 202207040045 \\
    JOAO VICTOR SANTOS BRITO FERREIRA - 202207040028 \\
    JOEL TAVARES MIRANDA - 202206840054 \\
    KAUAN MIRANDA TAVARES - 202206840033 \\
    MARCO ANTONIO DO ESPIRITO SANTO MAUES JUNIOR - 202206840038 \\
%\end{tabular}
}
\local{Belém}
\data{2023}
\orientador{Prof. Dr. Diego Lisboa Cardoso}
\tipotrabalho{Monografia}

% o nome da instituição e a área de concentração 
\preambulo{Relatório do trabalho 6 de Sistemas Operacionais.}
%\sobrenome{Sobrenome}
%\nome{Nome}
%\palavraschave{%

%}
%\datadadefesa{Data da Defesa: 09 de Março de 2017}%07 de Dezembro de 2016}
\conceito{Conceito: Excelente}
\faculdadedoorientador{Faculdade de Biotecnologia - UFPA}
\primeiromembrodabanca{Prof. Dr. Nome Sobrenome}
\faculdadedoprimeiromembrodabanca{Faculdade de Computação - UFPA}
\segundomembrodabanca{Prof. Dra. Nome Sobrenome}
\faculdadedosegundomembrodabanca{Faculdade de Biotecnologia - UFPA}
% -------------------------------------------------------------------------
% ---
% Configurações de aparência do PDF final
% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}
% informações do PDF
\makeatletter
\hypersetup{
     	%pagebackref=true,
		pdftitle={\imprimirtitulo}, 
		pdfauthor={\imprimirautor},
    	pdfsubject={\imprimirpreambulo},
	    pdfcreator={LaTeX with abnTeX2},
		pdfkeywords={\imprimirpalavraschave}, 
		colorlinks=true,       		% false: boxed links; true: colored links
    	linkcolor=black,          	% color of internal links
    	citecolor=black,        		% color of links to bibliography
    	filecolor=magenta,      		% color of file links
		urlcolor=blue,
		bookmarksdepth=4,
        breaklinks=true
}
\makeatother
% --- 
% Espaçamentos entre linhas e parágrafos 
% --- 
% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}
% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip
% compila o indice
% ---
\makeindex
% ---

% -------------------------------------------------------------------------
% ---------------------------INICIO DO DOCUMENTO---------------------------
% -------------------------------------------------------------------------
\begin{document}
% Seleciona o idioma do documento (conforme pacotes do babel)
\selectlanguage{brazil}
% Retira espaço extra obsoleto entre as frases.
\frenchspacing 
% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% ---
% Capa
% ---
\imprimircapa
% ---

% ---
% Folha de rosto

\imprimirfolhaderosto

\newpage

\setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo

\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---
% ---------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% ----------------------------------------------------------
% Introdução
% ----------------------------------------------------------

\chapter{Introdução}
O sistema de arquivos é uma peça fundamental para o gerenciamento eficiente de dados em 
sistemas operacionais. Entre as diversas opções disponíveis, a escolhida para este trabalho 
foi o sistema de arquivos ext4, ou Quarta Extensão, que destaca-se como uma escolha proeminente para ambientes 
baseados em Linux. Ao longo deste trabalho serão apresentados diversos aspectos, características e benchmarks de desempenho 
do sistema ext4.

\chapter{Apresentação do Sistema}

O Ext4, ou Fourth Extended Filesystem, é uma evolução do sistema de arquivos Ext3, desenvolvido 
especificamente para o sistema operacional Linux. Sua criação foi motivada pela necessidade 
de aprimorar as funcionalidades do Ext3 e acompanhar as demandas crescentes de armazenamento e 
processamento de dados na era moderna da computação. Ao abordar as limitações do Ext3, o Ext4 
oferece uma série de inovações que vão além do seu antecessor.

Com o objetivo de proporcionar um ambiente de armazenamento mais eficiente e confiável, o 
Ext4 introduz melhorias significativas em termos de capacidade, desempenho e segurança. 
Sua arquitetura foi projetada para suportar volumes de dados consideravelmente maiores, 
oferecendo maior flexibilidade para lidar com as demandas crescentes das aplicações contemporâneas. 
Dentre as características e aprimoramentos do Ext4 iremos citar algumas principais como a Retrocompatibilidade,
o Journaling e as evoluções em termo de capacidade, velocidade e tamanho de arquivos.

\section{Capacidade, Velocidade e Tamanho de Arquivos}
%Descreva a capacidade do sistema, velocidade e o suporte a arquivos grandes.
A capacidade do sistema de arquivos Ext4 é notavelmente extensa, com um tamanho máximo teórico de 1 exabyte. Essa 
ampla capacidade o torna ideal para lidar com grandes volumes de dados em ambientes Linux, oferecendo suporte a 
sistemas de arquivos significativamente grandes.

Em termos de velocidade, o Ext4 apresenta melhorias significativas em relação ao Ext3, principalmente devido 
à implementação de extensões. Ao organizar os dados em blocos contíguos, o Ext4 reduz a fragmentação, melhorando 
a eficiência no acesso aos dados e otimizando o desempenho global do sistema.

O tamanho máximo do arquivo, aumentado para 16 terabytes, proporciona uma flexibilidade substancial ao lidar 
com arquivos grandes. Essa expansão é crucial em ambientes que exigem o armazenamento e a manipulação de dados 
massivos, garantindo que o Ext4 atenda às demandas de cenários que envolvem arquivos consideravelmente grandes.


\chapter{Sistema de Alocação de Arquivos}
%Explicação sobre como o ext4 aloca arquivos no disco.
No Ext4 o a alocação de arquivos desempenha um papel vital na organização e na gestão eficiente do espaço em disco. 
Dito isso, o Ext4 utiliza uma estrutura aprimorada em comparação aos seus predecessores, Ext2 e Ext3, para otimizaro 
o desempenho e a eficiência,a seguir são apresentados alguns aspectos da alocação no Ext4

%\section{Extensões (Extents)}
%Uma das melhorias significativas introduzidas no Ext4 é o conceito de \textit{extensões} ou \textit{extents}. Em vez de manter listas detalhadas de blocos individuais para armazenar dados de um arquivo, o Ext4 organiza os dados em extensões, que são sequências de blocos contíguos. Essa abordagem ajuda a reduzir a fragmentação do sistema de arquivos, melhorando a eficiência no acesso aos dados.

\section{Alocação por Reservas no Sistema de Arquivos \texttt{ext}}
A alocação por reservas é uma estratégia fundamental no sistema de arquivos \texttt{ext}, projetada para otimizar o gerenciamento de espaço em disco e melhorar o desempenho do sistema. Essa técnica oferece uma abordagem proativa, reservando antecipadamente uma parte do disco para um arquivo antes mesmo de seu conteúdo ser gravado.

Ao criar um novo arquivo no sistema de arquivos \texttt{ext}, uma porção específica de espaço em disco é designada como reserva para esse arquivo. Essa alocação antecipada pode ser determinada com base em estimativas do tamanho futuro do arquivo ou seguir uma política fixa de reserva. Quando o conteúdo do arquivo é gravado, ele utiliza o espaço reservado, proporcionando uma eficiente distribuição do armazenamento.

\subsection{Vantagens}
A alocação por reservas oferece diversas vantagens cruciais:

\begin{itemize}
    \item \textbf{Desempenho Sustentado:} Ao reservar espaço antecipadamente, reduz-se a fragmentação do disco, mantendo um desempenho sustentado do sistema.
    
    \item \textbf{Prevenção de Fragmentação Extensiva:} Evita a fragmentação extensiva que pode ocorrer quando arquivos crescem incrementalmente ao longo do tempo sem reservas.
    
    \item \textbf{Otimização de Espaço:} Minimiza o desperdício de espaço em disco, especialmente em relação a arquivos pequenos, ao garantir uma alocação precisa e eficiente.
\end{itemize}

\subsection{Implementação Prática}
No sistema de arquivos \texttt{ext}, a alocação por reservas pode ser aplicada durante a criação de um arquivo. Por exemplo:


\begin{lstlisting}[caption={Exemplo de Alocação por Reservas}]
	$ touch novo_arquivo.txt   
	$ chattr +r 1M novo_arquivo.txt   
\end{lstlisting}
	
Este comando reserva 1 megabyte para o arquivo \texttt{novo\_arquivo.txt}.

A alocação por reservas no sistema de arquivos \texttt{ext} representa uma prática eficiente para garantir a integridade do sistema de arquivos, promovendo tanto a organização quanto o desempenho confiável.

\section{Alocação por Bloco Indireto no Sistema de Arquivos \texttt{ext}}
A alocação por bloco indireto é uma técnica avançada utilizada no sistema de arquivos \texttt{ext}, proporcionando uma gestão eficiente de grandes quantidades de dados. Essa estratégia utiliza uma estrutura adicional, chamada bloco indireto, para otimizar o acesso e a alocação de dados.

Ao lidar com arquivos extensos, a alocação por bloco indireto permite a criação de uma camada adicional entre os blocos de dados e o inode. Em vez de armazenar diretamente os endereços dos blocos de dados no inode, é utilizado um bloco indireto. Esse bloco indireto contém endereços de blocos de dados, proporcionando uma abstração eficiente para acessar grandes volumes de dados.

\subsection{Vantagens}
A alocação por bloco indireto apresenta diversas vantagens:

\begin{itemize}
    \item \textbf{Gestão Eficiente de Grandes Arquivos:} Permite a manipulação eficiente de arquivos grandes, facilitando a alocação dinâmica de blocos de dados.
    
    \item \textbf{Redução de Overhead no Inode:} Ao utilizar blocos indiretos, o inode permanece compacto, reduzindo o overhead associado a armazenar uma grande quantidade de endereços de bloco diretamente.
    
    \item \textbf{Acesso Rápido:} Simplifica o acesso a grandes conjuntos de dados, promovendo um acesso mais rápido e eficiente.
\end{itemize}

\subsection{Implementação Prática}
A implementação prática da alocação por bloco indireto no sistema de arquivos \texttt{ext} envolve a criação de um bloco indireto durante a criação do arquivo. Por exemplo:

\begin{lstlisting}[language=bash, caption={Exemplo de Alocação por Bloco Indireto}]
$ touch arquivo_grande.txt  
$ chattr +i bloco_indireto.txt  
$ chattr +B bloco_indireto.txt arquivo\_grande.txt  
\end{lstlisting}

Neste exemplo, um bloco indireto é criado e associado ao arquivo \texttt{arquivo\_grande.txt} para otimizar a alocação de blocos de dados.

A alocação por bloco indireto é uma estratégia avançada que contribui para a eficiência e desempenho do sistema de arquivos \texttt{ext}, especialmente ao lidar com grandes volumes de dados.

\section{Tamanho de Bloco Variável no Sistema de Arquivos \texttt{ext}}
A abordagem de tamanho de bloco variável é uma característica avançada do sistema de arquivos \texttt{ext}, permitindo a flexibilidade na alocação de espaço em disco, especialmente ao lidar com diferentes tipos de arquivos.

Ao contrário de sistemas de arquivos com tamanho de bloco fixo, o \texttt{ext} oferece a capacidade de variar o tamanho dos blocos de dados. Cada arquivo pode ser associado a um tamanho de bloco específico, ajustando-se dinamicamente às necessidades do conteúdo. Isso significa que arquivos pequenos podem compartilhar blocos com outros, enquanto arquivos maiores podem ter blocos maiores, otimizando a utilização do espaço em disco.

\subsection{Vantagens}
A implementação de tamanho de bloco variável apresenta várias vantagens:

\begin{itemize}
    \item \textbf{Otimização de Espaço:} Permite uma alocação mais eficiente de espaço, especialmente para arquivos de diferentes tamanhos.
    
    \item \textbf{Redução de Fragmentação:} Ao adaptar o tamanho do bloco às necessidades do arquivo, a fragmentação é reduzida, contribuindo para um melhor desempenho do sistema.
    
    \item \textbf{Flexibilidade para Diferentes Tipos de Arquivos:} A capacidade de escolher tamanhos de bloco específicos para diferentes tipos de arquivos otimiza o desempenho e a gestão de recursos.
\end{itemize}

\subsection{Implementação Prática}
A implementação prática do tamanho de bloco variável no sistema de arquivos \texttt{ext} envolve a configuração do tamanho de bloco no momento da formatação do sistema de arquivos. Por exemplo:

\begin{lstlisting}[language=bash, caption={Exemplo de Tamanho de Bloco Variável}]
$ mkfs.ext4 -b 4096 -O ^uninit_bg /dev/sdX1
\end{lstlisting}

Neste exemplo, o comando \texttt{mkfs.ext4} é utilizado para formatar a partição \texttt{/dev/sdX1} com um tamanho de bloco de 4096 bytes.

A capacidade de ajustar dinamicamente o tamanho do bloco oferece uma abordagem flexível e eficiente na gestão do espaço em disco no sistema de arquivos \texttt{ext}.

\section{Alocação Pré-Alocada no Sistema de Arquivos \texttt{ext}}
A alocação pré-alocada é uma técnica no sistema de arquivos \texttt{ext} que envolve a reserva antecipada de espaço em disco para um arquivo, mas com uma abordagem mais flexível em comparação com a alocação por reservas convencional.

Ao contrário da alocação por reservas, onde um tamanho fixo é reservado antecipadamente, a alocação pré-alocada permite que um arquivo solicite uma quantidade inicial de espaço e, ao longo do tempo, solicite mais espaço conforme necessário. Isso proporciona uma flexibilidade dinâmica, permitindo a adaptação do tamanho do arquivo sem a necessidade de uma reserva estática.

\subsection{Vantagens}
A alocação pré-alocada oferece diversas vantagens:

\begin{itemize}
    \item \textbf{Flexibilidade Dinâmica:} Os arquivos podem crescer dinamicamente, solicitando mais espaço à medida que necessário, evitando reservas estáticas excessivas.
    
    \item \textbf{Otimização do Uso de Espaço:} O sistema pode otimizar o uso de espaço em disco, alocando eficientemente apenas a quantidade necessária.
    
    \item \textbf{Manutenção de Desempenho:} Evita a fragmentação excessiva, mantendo um desempenho consistente ao longo do tempo.
\end{itemize}

\subsection{Implementação Prática}
A implementação prática da alocação pré-alocada no sistema de arquivos \texttt{ext} envolve o uso de comandos específicos durante a criação ou manipulação de arquivos. Por exemplo:

\begin{lstlisting}[language=bash, caption={Exemplo de Alocação Pré-Alocada}]
$ fallocate -l 1G arquivo_prealocado.txt  
$ echo "Novo conteudo" >> arquivo_prealocado.txt   
\end{lstlisting}

Neste exemplo, o comando \texttt{fallocate} é utilizado para alocar inicialmente 1 gigabyte para o arquivo \texttt{arquivo\_prealocado.txt}. Conforme o conteúdo é adicionado, o sistema pode alocar mais espaço conforme necessário.

A alocação pré-alocada oferece uma abordagem dinâmica para o gerenciamento de espaço em disco, adaptando-se às necessidades variáveis dos arquivos ao longo do tempo.

\chapter{Gestão do Espaço Livre no Ext4}

A eficiente gestão do espaço livre é uma componente crucial para garantir o desempenho, a confiabilidade e a integridade do sistema de arquivos Ext4. Neste capítulo, exploraremos as estratégias e características fundamentais implementadas no Ext4 para otimizar o uso do espaço disponível e minimizar a fragmentação.

\section{Bitmap de Blocos Livres}

O Ext4 utiliza um \textit{bitmap de blocos livres} para rastrear o estado de cada bloco no sistema de arquivos. Cada grupo de blocos possui um mapa de bits indicando quais blocos estão livres e quais estão em uso. Esse método eficiente permite uma alocação rápida de espaço e é crucial para a gestão eficaz do espaço livre, garantindo uma utilização otimizada dos recursos.

\section{Trim/Discard}

O Ext4 oferece suporte ao comando \textit{Trim/Discard}, especialmente benéfico em ambientes que utilizam dispositivos de armazenamento SSD. Esse comando notifica o sistema de arquivos sobre blocos que não estão mais em uso, permitindo que o sistema informe ao SSD para liberar esses blocos. Essa prática melhora a eficiência e prolonga a vida útil do SSD, uma consideração vital em ambientes modernos que fazem uso extensivo de armazenamento em estado sólido.

\section{Reserva de Espaço}

Para prevenir situações críticas de falta de espaço, o Ext4 incorpora a \textit{reserva de espaço}. Uma porcentagem do espaço disponível é reservada exclusivamente para o superusuário e operações do sistema. Isso garante que mesmo em condições de carga intensa, o sistema terá espaço suficiente para realizar operações essenciais. A capacidade de ajustar a porcentagem de reserva oferece flexibilidade para adaptar o sistema de arquivos a diferentes necessidades e cargas de trabalho.

Em conjunto, essas estratégias e características de gestão do espaço livre no Ext4 contribuem para um ambiente de armazenamento eficiente, resiliente e adaptável. O sistema de arquivos é projetado para lidar com grandes volumes de dados, oferecendo desempenho robusto e confiabilidade em diversas situações.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

\chapter{Estrutura do Sistema de Arquivos}
%Descrição da estrutura interna do ext4, destacando a organização em grupos de blocos.

O superbloco no Ext4 é bastante semelhante ao de seus antecessores, com a adição de novos campos para 
suportar números de bloco de 64 bits. Até o momento, os campos de carimbo de data e hora no superbloco 
ainda são de 32 bits e não possuem um campo de bits mais significativos associado a eles; no entanto, 
destaca-se que o campo \texttt{s\_log\_groups\_per\_flex} desempenha um papel crucial na organização 
dos grupos de blocos. Nas versões mais recentes do kernel, o superbloco também incorpora campos 
destinados ao rastreamento de erros e à criação de snapshots.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Grupos de Blocos}
O Ext4 mantém estruturas fundamentais, mas introduz diferenças notáveis na organização dos grupos 
de blocos. Um desafio enfrentado é o limite de 128 MB por grupo de blocos, que afeta o tamanho total 
do sistema de arquivos. Duas soluções propostas são o recurso de meta-grupo de blocos e o recurso de 
flex-grupo de blocos.

O meta-grupo de blocos possibilita a criação de meta-grupos compostos por uma série de grupos de 
blocos, todos descritos por um único bloco de descritor. Detalhes adicionais indicam que backups 
dos descritores de meta-grupo de blocos são armazenados no segundo e último grupo de cada meta-grupo de blocos.

A Figura \ref{fig:9} ilustra como o recurso de flex-grupo de blocos estende a ideia anterior 
de criar grandes áreas contíguas de grupos de blocos. Isso é feito movendo os mapas de bits de bloco e 
inode, juntamente com as tabelas de inode, para o primeiro grupo de blocos em um flex-grupo de blocos, 
junto com os descritores de grupo. Com o recurso de superbloco esparsamente ativado por padrão, alguns
grupos de blocos podem conter cópias de backup do superbloco, descritores de grupo e blocos de 
crescimento de descritores de grupo.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.36\textwidth]{fig9.jpg}
	\caption{Layout Flexível de Grupos de Blocos}
	\label{fig:9}
\end{figure}

Ao levantar a restrição dos blocos de metadados terem que residir no grupo de blocos ao qual se 
referem, é possível criar um grupo de blocos virtual maior. Isso permite a alocação de blocos de
dados contíguos livres através das fronteiras do grupo. Nas discussões nas listas de desenvolvimento, 
a questão de se as duas opções devem ter diferentes flags de recursos foi abordada. Ficou acordado 
que isso era necessário para manter uma definição clara de \texttt{META\_BG} e \texttt{FLEX\_BG}. 
O recurso \texttt{FLEX\_BG} foi detalhado, pois é selecionado por padrão no arquivo de configuração \texttt{mke2fs}.

\section{Extents (Extensões)}

Outra característica essencial do Ext4 é a adoção de \textit{"extents"} em vez do método de mapeamento 
de blocos previamente utilizado. Os \textit{"extents"} são mais eficientes 
para mapear blocos de dados de arquivos grandes e contíguos, pois sua estrutura inclui o endereço do 
primeiro bloco físico de dados seguido por um comprimento. A Figura \ref{fig:fig10} exibe a estrutura 
do \textit{"extent"} no Ext4, permitindo a sumarização de até 215 blocos com uma única entrada. 
Quando o sistema de arquivos tem um tamanho de bloco de 4 KB, isso mapeia até 128 MB de dados 
com uma única entrada, usando o bit mais alto do campo de comprimento para pré-alocação persistente.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{fig10.jpg}
    \caption{Estrutura do \textit{"extent"} no Ext4 \cite{matur}.}
    \label{fig:fig10}
\end{figure}

De acordo com \cite{matur}, um inode no Ext4 pode conter até quatro \textit{"extents"}. A 
colocação desses \textit{"extents"} no Ext4 é onde anteriormente estavam os ponteiros de bloco no 
Ext3. O formato inclui uma matriz de 60 bytes, com os primeiros 12 bytes contendo um cabeçalho de 
\textit{"extent"}. A estrutura do cabeçalho de \textit{"extent"} é composta pelos campos 
\textit{eh\_magic}, \textit{eh\_entries}, \textit{eh\_max}, \textit{eh\_depth} 
(2 bytes cada) e \textit{eh\_generation} (4 bytes), sendo o número mágico 0xf30A. 
Quando um arquivo é altamente fragmentado, muito grande ou esparsamente distribuído, 
uma árvore de \textit{"extent"} é construída, conforme mostrado na Figura \ref{fig:fig11}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{fig11.jpg}
    \caption{Estrutura da árvore de \textit{"extents"} no Ext4 \cite{matur}.}
    \label{fig:fig11}
\end{figure}

A estrutura de índice 
de \textit{"extent"} atua como uma estrutura intermediária, apontando para um bloco que 
contém outras estruturas que, por sua vez, apontam para dados. Esta estrutura possui um campo
\textit{ei\_block} (4 bytes) usado para denotar o bloco inicial do arquivo ao qual o índice se 
refere. As árvores de \textit{"extents"} válidas devem aderir a regras específicas, 
como a presença do cabeçalho de \textit{"extent"} em cada nó e a ordenação crescente dos 
campos \textit{ee\_block} em nós folha, além do aumento nos valores \textit{ei\_block} em nós de índice.

É importante observar que essas considerações de \textit{"extents"} proporcionam maior eficiência 
no mapeamento de grandes volumes de dados contíguos, oferecendo benefícios significativos ao 
desempenho e à gestão de espaço em disco no Ext4. Para uma visualização mais detalhada dessas 
estruturas, consulte as Figuras \ref{fig:fig10} e \ref{fig:fig11} em \cite{matur}.

\section{Inodes e Tempo no Ext4}

Como observado por \cite{matur} e \cite{xia}, o Ext3 é limitado à resolução de segundos 
no nível do sistema de arquivos. Isso é abordado no Ext4 modificando e estendendo a estrutura de 
inode. Embora o Ext3 suporte tamanhos diferentes de inode que são potências de dois maiores que 128 
bytes até o tamanho de um bloco de sistema de arquivos, 128 bytes é o tamanho padrão. As estruturas 
mais recentes no Ext4 serão, por padrão, de 256 bytes \cite{matur}. Este espaço permite ao 
Ext4 suportar carimbos de tempo em nanossegundos e números de versão de inode de 64 bits. 
Conforme mostrado na Figura \ref{fig:ext4-inode}, os primeiros 128 bytes permanecem em 
grande parte iguais, enquanto os novos campos são adicionados ao final da estrutura. 
Além disso, um novo campo de carimbo de tempo foi adicionado para documentar o momento 
da criação do arquivo. Cada campo de carimbo de tempo no inode, com exceção do carimbo de tempo de 
exclusão, possui um campo de 32 bits correspondente. Nesse espaço, apenas os 30 bits superiores são 
usados para representação em nanossegundos. Os 2 bits restantes são usados como bits mais significativos 
da segunda parte dos carimbos de tempo, adiando assim o problema de 2038 por 272 anos. 
Essa melhoria na resolução de tempo do ponto de vista do sistema de arquivos pode ser 
útil para pesquisas futuras em forense computacional e segurança. O espaço restante é 
ocupado por atributos estendidos rápidos. Nos primeiros 128 bytes, o número de fragmento 
de 1 byte, o tamanho do fragmento de 1 byte e um campo de preenchimento de 2 bytes foram 
substituídos pelos campos \texttt{i\_blocks\_high} e \texttt{file\_acl\_high}, cada um com 16 bits.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.34\textwidth]{fig12.png}
  \caption{Ext4 inode. Original apareceu em \cite{matur}.}
  \label{fig:ext4-inode}
\end{figure}

Embora o tamanho padrão dos inodes do Ext4 seja de 256 bytes, sistemas de 
arquivos Ext4 podem ser criados com um tamanho de inode de 128 bytes. Nesse caso, os campos 
\texttt{i\_ctime\_extra}, \texttt{i\_mtime\_extra}, \texttt{i\_atime\_extra}, \texttt{i\_crtime}, 
\texttt{i\_crtime\_extra} e \texttt{i\_version\_hi} não estarão presentes. Para os campos 
relacionados a carimbos de tempo, isso resulta nos benefícios mencionados anteriormente de 
suporte a subsegundos, uma extensão de 2 bits para carimbos de tempo e a perda do carimbo de tempo de criação.

Todas as alterações na estrutura de dados afetaram o \textit{journaling}, pois o JBD (Seção 2.2) 
foi ramificado para JBD2, que pode suportar o \textit{journaling} de sistemas de arquivos de 32 bits e 64 bits.

\chapter{Desempenho: Benchmarks}


% Definindo cores personalizadas para o código Python    % Para definir cores personalizadas

% Definindo cores personalizadas para o código Python no estilo Drácula
\definecolor{draculapurple}{RGB}{189, 147, 249}
\definecolor{draculagreen}{RGB}{80, 250, 123}
\definecolor{draculayellow}{RGB}{255, 184, 108}
\definecolor{draculacyan}{RGB}{139, 233, 253}
\definecolor{draculared}{RGB}{255, 85, 85}
\definecolor{draculablack}{RGB}{40, 42, 54}
\definecolor{draculawhite}{RGB}{248, 248, 242}
\definecolor{draculagray}{RGB}{68, 71, 90}

\lstdefinestyle{dracula}{
    backgroundcolor=\color{draculablack},   
    commentstyle=\color{draculagreen},
    keywordstyle=\color{draculacyan},
    numberstyle=\tiny\color{draculayellow},
    stringstyle=\color{draculapurple},
    basicstyle=\footnotesize\ttfamily\color{draculawhite},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=dracula}




Nesta seção, apresentamos um conjunto de testes de desempenho realizados em 
sistemas operacionais, utilizando benchmarks que incluem testes de leitura e 
escrita sequencial, bem como testes de leitura e escrita aleatória. Os testes 
foram conduzidos em 12 arquivos, cada um com tamanho de 1GB.

\section{Código de Benchmark}

A seguir, apresentamos o código em Python utilizado para realizar os testes:

\begin{lstlisting}[language=Python, caption={Código de Benchmark}, label=benchmark_code]
	import os
	import time
	import random
	
	def write_sequential(file_path, file_size_mb, block_size_kb):
		with open(file_path, 'wb') as f:
			for _ in range(file_size_mb * 1024 // block_size_kb):
			f.write(os.urandom(1024*1024* 1024)) 
	
	def read_sequential(file_path, block_size_kb):
		with open(file_path, 'rb') as f:
			while f.read(block_size_kb * 1024):
				pass
	
	def write_random(file_path, file_size_mb, block_size_kb):
		with open(file_path, 'wb') as f:
			for _ in range(file_size_mb * 1024 // block_size_kb):
				pos = random.randint(0, file_size_mb * 1024 * 1024 - block_size_kb * 1024)
				f.seek(pos)
				f.write(os.urandom(block_size_kb * 1024))
	
	def read_random(file_path, file_size_mb, block_size_kb):
		with open(file_path, 'rb') as f:
			for _ in range(file_size_mb * 1024 // block_size_kb):
				pos = random.randint(0, file_size_mb * 1024 * 1024 - block_size_kb * 1024)
				f.seek(pos)
				f.read(block_size_kb * 1024)
	
	def run_tests():
		file_size_mb = 1024
		block_size_kb = 4
		num_files = 12
	
		for i in range(1, num_files + 1):
			file_path = f'arquivo{i}.dat'
	
			print(f"Running tests for {file_path}...")
			
			start_time = time.time()
			write_sequential(file_path, file_size_mb, block_size_kb)
			elapsed_time = time.time() - start_time
			print(f"Sequential Write: {elapsed_time:.2f} seconds")
	
			start_time = time.time()
			read_sequential(file_path, block_size_kb)
			elapsed_time = time.time() - start_time
			print(f"Sequential Read: {elapsed_time:.2f} seconds")
	
			start_time = time.time()
			write_random(file_path, file_size_mb, block_size_kb)
			elapsed_time = time.time() - start_time
			print(f"Random Write: {elapsed_time:.2f} seconds")
	
			start_time = time.time()
			read_random(file_path, file_size_mb, block_size_kb)
			elapsed_time = time.time() - start_time
			print(f"Random Read: {elapsed_time:.2f} seconds")
	
	if __name__ == "__main__":
		run_tests()
\end{lstlisting}


O código consiste em funções para realizar testes de leitura e escrita sequencial, 
bem como testes de leitura e escrita aleatória. O desempenho é medido em termos do 
tempo necessário para realizar essas operações. Cada teste é executado em 12 arquivos 
distintos, cada um com um tamanho de 1GB.

\section{Resultados dos Testes}

\subsection{Teste de Leitura Sequencial}

Neste teste, avaliamos o desempenho da leitura sequencial em diferentes arquivos. 
O processo consiste em ler dados de maneira contínua, sem saltos, percorrendo o 
arquivo de início ao fim. A Figura~\ref{fig:sr} apresenta os tempos de leitura 
sequencial para cada arquivo, destacando as variações de desempenho entre eles.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{SeqRead.png}
    \caption{Tempos de Leitura Sequencial para Cada Arquivo.}
    \label{fig:sr}
\end{figure}

% Inclua tabelas ou gráficos com os resultados do teste de leitura sequencial aqui...

\subsection{Teste de Escrita Sequencial}

No teste de escrita sequencial, examinamos como o sistema lida com operações 
de escrita contínua em diferentes arquivos. Isso envolve a gravação de dados 
de maneira consecutiva, sem movimentos aleatórios no arquivo. 
A Figura~\ref{fig:sw} exibe os tempos de escrita sequencial para cada 
arquivo, proporcionando insights sobre a eficiência do sistema em 
operações de escrita ordenada.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{SeqWrite.png}
    \caption{Tempos de Escrita Sequencial para Cada Arquivo.}
    \label{fig:sw}
\end{figure}

% Inclua tabelas ou gráficos com os resultados do teste de escrita sequencial aqui...

\subsection{Teste de Leitura Aleatória}

No teste de leitura aleatória, avaliamos o desempenho da leitura de dados 
em posições não sequenciais nos arquivos. Isso simula a leitura de dados 
de maneira aleatória, sem seguir uma ordem específica. A Figura~\ref{fig:rr} 
ilustra os tempos de leitura aleatória para cada arquivo, oferecendo uma 
visão do comportamento do sistema diante de operações de leitura não lineares.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{RandomRead.png}
    \caption{Tempos de Leitura Aleatória para Cada Arquivo.}
    \label{fig:rr}
\end{figure}

% Inclua tabelas ou gráficos com os resultados do teste de leitura aleatória aqui...

\subsection{Teste de Escrita Aleatória}

O teste de escrita aleatória explora como o sistema lida com operações de 
escrita em posições não sequenciais nos arquivos. Isso inclui a gravação 
de dados em locais arbitrários, sem seguir uma ordem específica. 
A Figura~\ref{fig:rw} apresenta os tempos de escrita aleatória para cada arquivo, 
permitindo a análise do desempenho do sistema em cenários de gravação não linear.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{RandomWrite.png}
    \caption{Tempos de Escrita Aleatória para Cada Arquivo.}
    \label{fig:rw}
\end{figure}

\section{Considerações Importantes para o Benchmark}

Ao analisar os tempos de execução em um benchmark de sistema de arquivos, é crucial levar em 
consideração vários fatores que podem influenciar os resultados. A seguir, destacamos
algumas considerações essenciais:

\subsection{Hardware}

O desempenho do sistema de arquivos é fortemente influenciado pelo hardware 
subjacente. Características como o tipo e a velocidade do disco rígido (HDD), 
o tipo e a configuração do disco de estado sólido (SSD), a quantidade e a 
velocidade da memória RAM, e a capacidade do processador (CPU) podem ter 
impactos significativos nos resultados do benchmark. Em nossa análise foi usado
uma máquina com as características especificadas na tabela \ref{tab:ideapad_specs}


\begin{table}[ht]
    \centering
    \caption{Especificações do Hardware usado}
    \begin{tabular}{@{}ll@{}}
        \toprule
        \textbf{Componente} & \textbf{Especificação} \\
        \midrule
        Processador & Intel Core i3-10110U \\
        Memória RAM & 8 GB DDR4 (2x4) 2666 \\
        Armazenamento & SSD NVME 128 GB \\
        Sistema Operacional & Ubuntu 22.04 LTS \\
        \bottomrule
    \end{tabular}
    \label{tab:ideapad_specs}
\end{table}
\subsection{Tipo de Acesso}

Operações de leitura e escrita sequencial geralmente apresentam desempenho superior 
em comparação com operações aleatórias. A otimização do sistema de arquivos 
pode variar de acordo com o tipo específico de acesso.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{RandomVsSeq.png}
	\caption{Acessos sequencial e aleatório}
\end{figure}

\subsection{Tamanho dos Arquivos}

O tamanho dos arquivos utilizados nos testes pode influenciar os resultados. 
O comportamento do sistema de arquivos pode ser diferente dependendo do 
tamanho dos arquivos envolvidos.

%\subsection{Cache do Sistema Operacional}

%A presença de cache no sistema operacional pode impactar os tempos de leitura 
%e gravação. Operações subsequentes podem ser aceleradas se os dados estiverem 
%em cache, introduzindo variabilidades nos resultados.


\subsection{Cargas do Sistema}

Outras tarefas em execução no sistema podem impactar o desempenho dos 
testes. Recomenda-se realizar os benchmarks em um sistema relativamente 
inativo, como fizemos em nossa análise, para obter resultados mais consistentes.

\chapter{Conclusão}

Neste trabalho, realizamos benchmarks de desempenho em diferentes cenários 
de acesso a arquivos em um sistema operacional Linux com o sistema de arquivos Ext4, 
utilizando um computador com o hardware descrito na tabela \ref{tab:ideapad_specs}  
como ambiente de teste. Os testes incluíram operações de leitura e escrita 
sequencial, bem como leitura e escrita aleatória, em arquivos de tamanho fixo.

Ao analisar os resultados apresentados no gráfico geral de comparação de desempenho 
(Figura \ref{fig:oneforall}), observamos padrões interessantes. Os tempos de 
escrita sequencial, em geral, mantiveram-se estáveis, enquanto os tempos de 
leitura sequencial e os tempos de leitura e escrita aleatórias variaram 
consideravelmente entre os diferentes arquivos.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{oneforall_grafico.png}
	\caption{Acessos sequencial e aleatório}
	\label{fig:oneforall}
\end{figure}


Essas variações podem ser atribuídas a uma série de fatores, como a 
alocação de blocos, a presença de cache do sistema operacional, e a 
configuração específica do sistema de arquivos utilizado. É crucial 
considerar esses fatores ao interpretar os resultados.

Em resumo, este estudo fornece insights valiosos sobre o desempenho do 
sistema de arquivos em diferentes cenários. No entanto, para uma compreensão 
mais abrangente, seria necessário realizar análises mais detalhadas, 
considerando diversos parâmetros e cenários adicionais.
\postextual

\bibliography{bibliografia}

\cite{FAIRBANKS2012S118}
\cite{bovet_cesati_2005}
\cite{Tso}
\cite{matur}
\cite{kumar}

\end{document}
