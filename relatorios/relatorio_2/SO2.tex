\documentclass[
	% -- opções da classe memoir --
	12pt,				% tamanho da fonte
	openright,			% capítulos começam em pág ímpar (insere página vazia caso preciso)
	oneside,			% para impressão em frente e verso. Oposto a oneside
	a4paper,			% tamanho do papel.
	% -- opções da classe abntex2 --
	chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	french,				% idioma adicional para hifenização
	spanish,			% idioma adicional para hifenização
	brazil				% o último idioma é o principal do documento
	]{abntex2}
% ---
% Pacotes básicos 
% ---
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage{mathptmx}			% Usa a fonte Times New Roman
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{lastpage}			% Usado pela Ficha catalográfica
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{subcaption}				% Inclusão de gráficos lado a lado
\usepackage{microtype} 			% para melhorias de justificação
\usepackage{tabularx,ragged2e}	% Para inserir tabelas
\usepackage{multirow}			% Para mesclar células
\usepackage[dvipsnames,table,xcdraw]{xcolor}		% Permite adicionar cores nas linhas de tabelas
\usepackage{fancyvrb}			% Permite adicionar arquivos de texto
\usepackage[portuguese, ruled, linesnumbered]{algorithm2e} % Uso de algoritmos
\usepackage{amsfonts}			% Permite usar notação de conjuntos
\usepackage{amsmath}			% Permite citar equações
\usepackage{amsthm}				% Permite criar teoremas e experimentos
\usepackage[font={bf, small}, labelsep=endash, labelfont=bf]{caption}	% Faz legenda de figuras ficarem em negrito
\usepackage{cancel}				% Permite fazer expressão tendendo a zero
\usepackage{epstopdf}			% Converte eps para pdf
\usepackage[final]{pdfpages}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{float}



\newcolumntype{L}{>{\RaggedRight\arraybackslash}X}
% ---
% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}				% para geração de dummy text
% ---
% ---
% Pacotes de citações
% ---
%\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[alf, abnt-emphasize=bf]{abntex2cite}	% Citações padrão ABNT
% ---
% Customizações para o layout da UFPA
% ---
\usepackage{modelo-ufpa/ufpa}
% Muda o título de lista de ilustrações para lista de figuras
\addto\captionsbrazil{%
  \renewcommand{\listfigurename}%
    {Lista de Ilustrações}%
	\renewcommand{\listtablename}%
    {Lista de Tabelas}%
}
% Permite utilizar figuras sem precisar colocar o caminho absoluto
\graphicspath{{imagens/}}
% Define o ambiente de experimentos
\theoremstyle{definition}
\newtheorem{experimento}{Experimento}[section]
\newcommand{\experimentoautorefname}{Experimento}


% --------------------------------------------------------------
% Informações do TRABALHO
% --------------------------------------------------------------
\universidade{UNIVERSIDADE FEDERAL DO PARÁ}
\instituto{INSTITUTO DE TECNOLOGIA}
\faculdade{FACULDADE DE COMPUTAÇÃO E TELECOMUNICAÇÕES}
%\curso{CURSO DE BACHARELADO EM SISTEMAS DE INFORMAÇÃO}
\titulo{RELATÓRIO DE SISTEMAS OPERACIONAIS}
\autor{
%\begin{tabular}{l l}
    DAVID PINHEIRO DE SOUSA - 202207040045 \\
    JOAO VICTOR SANTOS BRITO FERREIRA - 202207040028 \\
    JOEL TAVARES MIRANDA - 202206840054 \\
    KAUAN MIRANDA TAVARES - 202206840033 \\
    MARCO ANTONIO DO ESPIRITO SANTO MAUES JUNIOR - 202206840038 \\
%\end{tabular}
}
\local{Belém}
\data{2023}
\orientador{Prof. Dr. Diego Lisboa Cardoso}
\tipotrabalho{Monografia}

% o nome da instituição e a área de concentração 
\preambulo{Relatório do trabalho 2 de Sistemas Operacionais.}
%\sobrenome{Sobrenome}
%\nome{Nome}
%\palavraschave{%

%}
%\datadadefesa{Data da Defesa: 09 de Março de 2017}%07 de Dezembro de 2016}
\conceito{Conceito: Excelente}
\faculdadedoorientador{Faculdade de Computação e Telecomunicações - UFPA}
%\primeiromembrodabanca{Prof. Dr. Nome Sobrenome}
%\faculdadedoprimeiromembrodabanca{}
%\segundomembrodabanca{}
%\faculdadedosegundomembrodabanca{}
% -------------------------------------------------------------------------
% ---
% Configurações de aparência do PDF final
% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}
% informações do PDF
\makeatletter
\hypersetup{
     	%pagebackref=true,
		pdftitle={\imprimirtitulo}, 
		pdfauthor={\imprimirautor},
    	pdfsubject={\imprimirpreambulo},
	    pdfcreator={LaTeX with abnTeX2},
		pdfkeywords={\imprimirpalavraschave}, 
		colorlinks=true,       		% false: boxed links; true: colored links
    	linkcolor=black,          	% color of internal links
    	citecolor=black,        		% color of links to bibliography
    	filecolor=magenta,      		% color of file links
		urlcolor=blue,
		bookmarksdepth=4,
        breaklinks=true
}
\makeatother
% --- 
% Espaçamentos entre linhas e parágrafos 
% --- 
% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}
% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip
% compila o indice
% ---
\makeindex
% ---

% -------------------------------------------------------------------------
% ---------------------------INICIO DO DOCUMENTO---------------------------
% -------------------------------------------------------------------------
\begin{document}
% Seleciona o idioma do documento (conforme pacotes do babel)
\selectlanguage{brazil}
% Retira espaço extra obsoleto entre as frases.
\frenchspacing 
% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% ---
% Capa
% ---
\imprimircapa
% ---

% ---
% Folha de rosto

\imprimirfolhaderosto

\newpage

\setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo

\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---
% ---------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% ----------------------------------------------------------
% Introdução
% ----------------------------------------------------------

\chapter{Introdução}

Este trabalho aborda a implementação de concorrência e 
sincronismo por meio da criação de processos e threads. O 
trabalho consiste em uma série de tarefas que exploram diferentes 
aspectos da criação de processos, comunicação entre processos e o 
uso de threads em um ambiente Linux. Através dessas atividades, 
pretendemos aprofundar nossa compreensão de como a concorrência é 
gerenciada em sistemas operacionais e como diferentes abordagens afetam 
o desempenho e o comportamento do programa.


\chapter{Objetivos}

O principal propósito deste trabalho é:

\begin{itemize}
    \item \textbf{Criação de Processos}:
    \begin{itemize}
        \item Implementar a criação de processos de acordo com as hierarquias e requisitos especificados, incluindo cenários com avô, pai e filho, bem como múltiplos filhos.
    \end{itemize}

    \item \textbf{Comunicação entre Processos e Threads}:
    \begin{itemize}
        \item Explorar a comunicação entre processos e threads, incluindo o compartilhamento de variáveis e recursos entre eles.
    \end{itemize}

    \item \textbf{Comparação de Desempenho}:
    \begin{itemize}
        \item Comparar o desempenho da criação de processos e threads para realizar as tarefas do programa. Calcular a média de tempo de 20 simulações para obter uma análise precisa.
    \end{itemize}

    \item \textbf{Teste de Limites Máximos}:
    \begin{itemize}
        \item Testar e identificar os limites máximos da quantidade de processos e threads que podem ser disparados em um ambiente Linux. 
    \end{itemize}
\end{itemize}

  

\chapter{Desenvolvimento (Programa explicado e Cópias das telas do emulador.)}

Primeiramente, o desenvolvimento deste trabalho gira em torno da criação
de processos, que é uma parte fundamental dos sistemas operacionais. 
Os sistemas operacionais permitem que programas criem novos processos, que 
podem ser vistos como tarefas independentes que compartilham recursos do sistema. 

A criação de processos deste trabalho é baseada nos requisitos e níveis de hierarquia descritos 
no roteiro e evidenciados nas seções deste capítulo.

%\begin{enumerate}
%    \item 
%   \item
%    \item Programa com 1 Avô, 1 Pai e 1 Filho, "elimine" o processo 'Pai' e veja quem será o novo pai do processo 'Filho'.
%   \item Programa que cria 3 threads. A primeira escreve na tela “A”, a segunda “B” e a terceira “C”. Faça que seja sempre escrito na tela “ABC”.
%    \item Para o processo Pai e filho, declare uma variável visível ao pai e ao filho, no pai inicialize a variável com 1 e imprima seu valor antes do fork(). No filho, altere o valor da variável para 5 e imprima o seu valor antes do exit(). Agora, no pai, imprima novamente o valor da variável após o filho ter alterado a variável - após a waitpid(). Justifique os resultados obtidos.
%    \item Ordenar um vetor de 100 posições em processos e threads. O filho ordena o vetor e o pai exibe os dados do vetor antes da criação do filho (fork) e depois da espera pelo filho (waitpid para processos). Eles usarão o mesmo vetor na memória? Justifique.
%    \item . Os limites máximos. Em ambiente linux os limites superiores da quantidade de processos e threads que podem ser disparados são configuráveis, testar e identificar.
%    \item Programa para comparar o desempenho para a realização da(s) tarefa(s) do programa através do uso de primitivas fork e através de threads (calcule a média de tempo de 20 simulações).
%\end{enumerate}

\section{Programa com 1 Avô, 1 Pai e 1 Filho}


A função \texttt{fork()} em C é comumente usada para criar novos processos. 
A chamada \texttt{fork()} cria uma cópia exata do processo existente, 
resultando em dois processos independentes - o processo pai e o processo filho. 
O processo pai e o processo filho compartilham o mesmo código, mas têm 
seu próprio espaço de endereçamento de memória. Isso é frequentemente usado 
para criar hierarquias de processos, onde um processo pai pode criar um ou 
mais processos filhos.

O código mostrado na figura \ref{fig:proc1} demonstra a criação de uma hierarquia de processos 
com um avô, um pai e um filho (neto) usando a função \texttt{fork()}. 
Aqui está uma descrição detalhada do código:

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{imagens/processos_1.png}
	\caption{Código em C. Disponível em: \href{https://github.com/jvictorferreira3301/Sistemas_Operacionais/blob/main/2_thread/2-1_processo_avo_pai_filho.c}{github.com/jvictorferreira3301/SistemasOperacionais/blob/main
    /2\_thread/2-1\_processo\_avo\_pai\_filho.c}}
	\label{fig:proc1}
\end{figure}


\begin{itemize}
    \item \texttt{\#include} direciona a inclusão de bibliotecas necessárias, como entrada/saída padrão e manipulação de processos.
    \item A função \texttt{main()} é o ponto de entrada do programa.
    \item \texttt{int PID\_pai} é uma variável inteira que armazenará o PID do processo pai.
    \item \texttt{PID\_pai = fork();} cria um novo processo através da chamada \texttt{fork()} e armazena o valor de retorno em \texttt{PID\_pai}. O processo pai receberá o PID do filho, enquanto o processo filho receberá 0. !!!!corrigir aqui!!!!
    \item O código verifica se \texttt{PID\_pai} é menor que 0, o que indicaria um erro na criação do processo pai, e nesse caso, exibe uma mensagem de erro e encerra o programa.
    \item Se \texttt{PID\_pai} for maior que 0, isso significa que estamos no processo pai. O código exibe o PID do processo avô (obtido com \texttt{getppid()}) e o PID do processo pai (obtido com \texttt{getpid()}). Em seguida, aguarda a conclusão do processo filho (neto) usando \texttt{wait(NULL)}.
    \item Se \texttt{PID\_pai} for igual a 0, isso significa que estamos no processo filho (neto). O código exibe o PID do processo filho (neto) e entra em um loop infinito, mantendo o processo filho em execução.
\end{itemize}

Em suma, esse código cria uma estrutura hierárquica de três processos: avô, 
pai e filho (neto). O processo avô cria o processo pai, 
que por sua vez cria o processo filho. Isso demonstra a 
criação de processos em uma hierarquia usando \texttt{fork()} e é 
um conceito fundamental em sistemas operacionais. Podemos ver 
a execução desse código na figura~\ref{fig:run1} no terminal ZSH do Linux.

\begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{imagens/run_processos_1.png}
	\caption{Execuçao do Código em C. }
	\label{fig:run1}
\end{figure}

\section{Programa com 1 Pai e 2 Filhos}

Nesta seção é mostrado o código em linguagem C que demonstra a 
criação de um processo pai e dois processos filhos. Essa demonstração ajudará 
a ilustrar o conceito de hierarquia de processos, onde um processo pai pode 
criar e controlar vários processos filhos.

Abaixo se encontra a descrição detalhada do código mostrado na figura \ref{fig:proc2}, e posteriormente, 
na figura \ref{fig:run2}, a execução do mesmo no terminal ZSH do Linux.


\begin{itemize}
    \item \texttt{\#include} direciona a inclusão de bibliotecas necessárias, como entrada/saída padrão e manipulação de processos.
    \item A função \texttt{main()} é o ponto de entrada do programa, onde a execução começa.
    \item \texttt{int pid\_filho1} é uma variável inteira que será usada para armazenar o PID do primeiro processo filho (Filho 1).
    \item \texttt{pid\_filho1 = fork();} cria um novo processo por meio da chamada da função \texttt{fork()} e armazena o valor de retorno em \texttt{pid\_filho1}. O processo pai receberá o PID do primeiro filho, enquanto o processo filho (Filho 1) receberá 0.
    \item O código verifica se \texttt{pid\_filho1} é menor que 0, o que indicaria um erro na criação do processo filho. Nesse caso, é exibida uma mensagem de erro e o programa é encerrado.
    \item Se \texttt{pid\_filho1} for maior que 0, isso significa que estamos no processo pai. O código exibe o PID do processo pai atual (obtido com \texttt{getpid()}). Em seguida, ele cria o segundo processo filho (Filho 2) usando outra chamada à função \texttt{fork()}, criando assim uma hierarquia de processos. 
    \item Se \texttt{pid\_filho2} for menor que 0, indica um erro na criação do segundo processo filho, e uma mensagem de erro é exibida.
    \item Se \texttt{pid\_filho2} for igual a 0, isso significa que estamos no segundo processo filho (Filho 2). O código exibe o PID do processo filho 2 e o PID de seu pai (processo pai). 
    \item O processo pai, identificado pelo \texttt{else}, aguarda a conclusão do primeiro filho (Filho 1) usando \texttt{wait(NULL)}.
    \item Posteriormente, o processo pai aguarda a conclusão do segundo filho (Filho 2) usando \texttt{wait(NULL)}. Finalmente, o processo pai encerra sua execução.

\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/processos_2.png}
    \caption{Código em C. Disponível em: \href{https://github.com/jvictorferreira3301/Sistemas_Operacionais/blob/main/2_thread/2-2_processo_pai_2filho.c}{github.com/jvictorferreira3301/SistemasOperacionais/blob/main
    /2\_thread/2-2\_processo\_pai\_2filho.c}}
    \label{fig:proc2}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/run_processos_2.png}
    \caption{Execução do Código em C.}
    \label{fig:run2}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555

\section{Programa com 1 Avô, 1 Pai e 1 Filho; Parricídio}

Neste tópico, abordaremos um cenário em que três processos estão 
envolvidos: um processo avô, um processo pai e um processo filho.
Vamos explorar como é possível "eliminar" o processo pai (por isso nomeamos de parricídio)
e identificar quem se torna o novo pai do processo filho. Isso ilustra a dinâmica de 
criação, terminação e hierarquia de processos em sistemas operacionais.

A seguir, mostramos a descrição completa do código em questão que é
apresentado na figura \ref{fig:proc3} e executado na figura \ref{fig:run3}.

\begin{itemize}
    \item \texttt{\#include} direciona a inclusão das bibliotecas necessárias, como entrada/saída padrão, manipulação de processos e sinais.

    \item O código inicia criando um processo avô, identificando e exibindo o PID do processo avô.

    \item Em seguida, o código cria um processo pai (Pai) usando a função \texttt{fork()}. O processo pai também exibe seu PID.

    \item O código entra em um bloco condicional onde, se o PID do processo pai for maior que zero, estamos no processo pai, e o código cria um processo filho (Filho) usando outra chamada à função \texttt{fork()}. O processo filho exibe seu PID.

    \item No processo filho, após um breve período de espera, o código "elimina" o processo pai usando o sinal \texttt{SIGKILL}. Em seguida, o processo filho aguarda um curto período para garantir que o processo pai seja encerrado.

    \item O código no processo filho, em seguida, exibe o PID de seu novo pai (que agora é o processo avô), demonstrando a mudança na hierarquia de processos.

\end{itemize}

Este código exemplifica a criação e manipulação de processos em sistemas operacionais, incluindo a dinâmica de hierarquia de processos e como é possível modificar essa hierarquia por meio da eliminação de processos.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.57\textwidth]{imagens/processos_3.png}
    \caption{Código em C. Disponível em: \href{https://github.com/jvictorferreira3301/Sistemas_Operacionais/blob/main/2_thread/2-3_parricidio.c}{github.com/jvictorferreira3301/SistemasOperacionais/blob/main
    /2\_thread/2-3\_parricidio.c.}} 
    \label{fig:proc3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{imagens/run_processos_3.png}
    \caption{Execução do Código em C.}
    \label{fig:run3}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Thread ABC}

Nesta seção, apresentaremos um exemplo prático em C, no qual três threads são 
criadas para imprimir as letras "A", "B" e "C" na tela, garantindo que 
a sequência "ABC" seja sempre exibida. Isso demonstrará como as threads 
podem ser usadas para coordenar tarefas concorrentes e sincronizar a saída.

O código que implementa as threads mencionadas pode ser visto na figura \ref{fig:proc4}
e sua execução na figura \ref{fig:run4}. Aqui esta uma descrição detalhada da implementação em C:

\begin{itemize}
    
    \item \texttt{\#include} direciona a inclusão das bibliotecas necessárias, como \texttt{pthread} para manipulação de threads, entrada/saída padrão e manipulação de erros.
    \item O código começa definindo uma constante \texttt{NUM\_THREADS} como 3, que representa o número de threads que serão criadas.
    \item A função \texttt{print\_abc} é definida para ser executada por cada thread. Ela recebe um parâmetro \texttt{threadid} que representa a identificação da thread. Dentro da função, o código verifica o valor de \texttt{threadid} e imprime "A," "B," ou "C" de acordo com o valor. Isso garante que cada thread gere sua respectiva letra.
    \item A função \texttt{main} é o ponto de entrada do programa. Ela cria um array de objetos \texttt{pthread\_t} chamado \texttt{thread} para representar as threads.
    \item Em um loop \texttt{for}, o código cria as threads. Para cada iteração, a função \texttt{pthread\_create} é chamada para criar uma thread. O parâmetro \texttt{thread[i]} é usado para armazenar o identificador da thread recém-criada. A função \texttt{print\_abc} é atribuída a cada thread, e o valor \texttt{i} é passado como parâmetro, que corresponde ao índice da thread. 
    \item O código também usa \texttt{pthread\_join} para esperar que cada thread termine sua execução antes de continuar. Isso garante que as threads sejam sincronizadas, de modo que a saída seja sempre "ABC."
    \item O código verifica se houve erros ao criar as threads e, se ocorrer algum erro, exibe uma mensagem de erro.
    \item O programa é encerrado com \texttt{pthread\_exit}.

\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{imagens/processos_4.png}
	\caption{Código em C. Disponível em: \href{https://github.com/jvictorferreira3301/Sistemas_Operacionais/blob/main/2_thread/2-4_threadABC.c}{github.com/jvictorferreira3301/SistemasOperacionais/blob/main
    /2\_thread/2-4\_threadABC.c.}}
	\label{fig:proc4}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{imagens/run_processos_4.png}
    \caption{Execução do Código em C.}
    \label{fig:run4}
\end{figure}

\section{Compartilhamento de Variáveis entre Processos}

Nesta seção, exploramos o compartilhamento de variáveis entre um processo pai e um 
processo filho. O programa em C na figura \ref{fig:proc5} que é executado na \ref{fig:run5} ilustra esse conceito, demonstrando 
como uma variável pode ser compartilhada entre esses dois processos e como as alterações 
feitas por um afetam o outro.

O código em C descrito abaixo apresenta a criação de processos e o compartilhamento de uma variável entre o processo pai e o processo filho:

\begin{figure}
    \centering
    \includegraphics[width=0.6 \textwidth]{imagens/processos_5.png}
    \caption{Código em C. Disponível em: \href{https://github.com/jvictorferreira3301/Sistemas_Operacionais/blob/main/2_thread/2-5_VariavelVisivel.c}{github.com/jvictorferreira3301/SistemasOperacionais/blob/main
    /2\_thread/2-5\_VariavelVisivel.c.}}
    \label{fig:proc5}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.7 \textwidth]{imagens/run_processos_5.png}
    \caption{Execução do Código em C.}
    \label{fig:run5}
\end{figure}

\begin{itemize}
    \item O código começa declarando uma variável chamada \texttt{visivel} que é compartilhada entre o processo pai e o processo filho. Inicialmente, o valor dessa variável é definido como 1 e é impresso no processo pai antes da criação do processo filho.
    \item Em seguida, o código chama a função \texttt{fork()} para criar um novo processo, que será o processo filho.
    \item O código verifica se a criação do processo filho foi bem-sucedida (quando \texttt{pid} é maior que 0). Se ocorrer algum erro, uma mensagem de erro é exibida.
    \item No processo pai, após a espera pelo processo filho (usando \texttt{wait}), o valor da variável \texttt{visivel} é impresso novamente. Isso demonstra que o processo pai e o processo filho compartilham a mesma variável na memória, e as alterações feitas por um processo são visíveis ao outro.
    \item No processo filho, o valor da variável \texttt{visivel} é alterado para 5, e esse novo valor é impresso no processo filho. Em seguida, o processo filho é encerrado com \texttt{exit(0)}.
    \item O código do processo pai continua a ser executado após a espera pelo processo filho.
\end{itemize}

\subsection{Justificativa dos Resultados}

A justificativa para os resultados obtidos é a seguinte:

- Antes do \texttt{fork()}, o processo pai e o processo filho compartilham a mesma variável \texttt{visivel} com valor 1. Isso ocorre porque, durante o \texttt{fork()}, o processo filho herda uma cópia idêntica do espaço de endereçamento do processo pai, incluindo o valor da variável.

- No processo filho, o valor da variável \texttt{visivel} é alterado para 5. Isso acontece no espaço de endereçamento do processo filho e não afeta o processo pai, já que eles têm espaços de endereçamento separados.

- Após o processo filho ter alterado a variável e ter sido encerrado, o processo pai imprime novamente o valor da variável. Como o processo pai e o processo filho têm espaços de endereçamento separados, a alteração feita pelo processo filho não afeta o valor da variável no processo pai. Portanto, o valor impresso pelo processo pai após o término do filho é 1.

Esses resultados demonstram o compartilhamento de variáveis entre processos, bem como o isolamento de seus espaços de endereçamento, o que evita que as alterações feitas em um processo afetem diretamente o outro.


\section{Vetor de 100 posições}


Nesta seção, exploramos a ordenação de um vetor de 100 posições em processos e discutimos o compartilhamento de memória entre processos no ambiente do sistema operacional. O programa em C a seguir ilustra o conceito de ordenação de vetor em processos e como os processos podem compartilhar uma parte da memória.

\begin{figure}
    \centering
    \includegraphics[width=0.8 \textwidth]{imagens/processos_6.png}
    \caption{Código em C. Disponível em: \href{https://github.com/jvictorferreira3301/Sistemas_Operacionais/blob/main/2_thread/2-6_Vetor100.c}{github.com/jvictorferreira3301/SistemasOperacionais/blob/main
    /2\_thread/2-6\_Vetor100.c.}}
    \label{fig:proc6}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1.0 \textwidth]{imagens/run_processos_6.png}
    \caption{Execução do Código em C.}
    \label{fig:run6}
\end{figure}

Abaixo apresentamos a descrição do código: 

\begin{itemize}
        \item \texttt{\#include} direciona a inclusão das bibliotecas necessárias, como entrada/saída padrão, manipulação de processos, manipulação de erros e funções para geração de números aleatórios.
    
        \item O código inicia criando um vetor de 100 posições chamado \texttt{vetor}, que será compartilhado entre o processo pai e o processo filho. Os valores do vetor são preenchidos com números inteiros aleatórios no intervalo de 0 a 1000.
    
        \item Antes de criar o processo filho, o processo pai exibe os valores do vetor. Isso mostra o estado inicial do vetor antes de qualquer alteração.
    
        \item Em seguida, o código cria um processo filho usando a função \texttt{fork()}. O processo filho recebe uma cópia do espaço de endereçamento do processo pai, incluindo o vetor.
    
        \item No processo pai, após esperar o processo filho terminar com \texttt{wait()}, os valores do vetor são novamente exibidos. Isso ilustra que o processo filho e o processo pai compartilham o mesmo vetor.
    
        \item No processo filho, o vetor é ordenado usando a função \texttt{qsort}.
    
        \item No entanto, as alterações feitas no vetor pelo processo filho não afetam o vetor no processo pai. 
    Portanto, no processo pai, os valores do vetor continuam os mesmos antes e depois da ordenação realizada pelo processo filho.
\end{itemize}



\subsection{Justificativa dos Resultados}

A justificativa para os resultados obtidos é a seguinte:

\begin{itemize}
    \item Antes do \texttt{fork()}, o processo pai e o processo filho compartilham o mesmo vetor na memória. Isso ocorre porque, durante o \texttt{fork()}, o processo filho herda uma cópia idêntica do espaço de endereçamento do processo pai, incluindo o vetor.

    \item No processo filho, o vetor é ordenado usando a função \texttt{qsort}. No entanto, devido ao modelo de espaço de endereço separado entre processos em sistemas Unix, incluindo o Linux, as alterações feitas no vetor pelo processo filho não afetam o vetor no processo pai. Portanto, no processo pai, os valores do vetor continuam os mesmos antes e depois da ordenação realizada pelo processo filho. Essa separação de espaço de endereço garante que as alterações feitas em um processo não se propaguem automaticamente para outros processos.

\end{itemize}

Essa abordagem destaca a importância de entender o modelo de espaço de endereço separado entre processos em sistemas Unix e como isso afeta o compartilhamento de memória e as alterações entre processos.


\section{Threads Vs. Processos: Limites Máximos}

\section{Benchmark}

Nesta seção, apresentamos um código na figura \ref{fig:proc8} que demonstra uma comparação 
de desempenho entre o uso de primitivas `fork` e threads para realizar tarefas 
concorrentes. O programa executa simulações para medir o tempo médio de 
execução em ambas as abordagens. Para a análise mais precisa foram realizados
execuções em 3 cenários: 10 simulações e 1000 tarefas, 20 simulações e 2000 tarefas,
30 simulações e 3000 tarefas. Os cenários podem ser vistos no gráfico da figura \ref{fig:graf}
e na figura \ref{fig:run8} junto com a execução.

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/processos_8.png}
    \caption{Código em C. Disponível em: \href{https://github.com/jvictorferreira3301/Sistemas_Operacionais/blob/main/2_thread/2-8_benchmark.c}{github.com/jvictorferreira3301/SistemasOperacionais/blob/main/2\_thread/2-8\_benchmark.c}}
    \label{fig:proc8}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{imagens/run_processos_8.png}
    \caption{Execução do Código em C.}
    \label{fig:run8}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{imagens/graf_fork_vs_threads.png}
    \caption{Gráfico comparativo com as médias dos tempos.}
    \label{fig:graf}
\end{figure}


\begin{itemize}
    \item \textbf{Bibliotecas Incluídas:} O código começa incluindo as bibliotecas necessárias, como `stdio.h`, `stdlib.h`, `unistd.h`, `sys/wait.h`, `pthread.h`, e `time.h`.

    \item \textbf{Definição de Constantes:} As constantes `NUM\_SIMULATIONS` e `NUM\_TASKS` são definidas para configurar o número de simulações a serem realizadas e o número de tarefas em cada simulação.

    \item \textbf{Função de Tarefa para Threads:} É definida uma função `task` que representa a tarefa a ser executada por threads. Esta função é onde a tarefa real seria implementada.

    \item \textbf{Função Principal:} A função `main` é onde o programa é controlado. O código realiza as seguintes etapas:
    
    \begin{itemize}
        \item Inicializa variáveis para medir o tempo de execução.
        
        \item Executa um loop para realizar 20 simulações de comparação de desempenho.
        
        \item Mede o tempo de execução usando primitivas `fork` em uma simulação e threads em outra.
        
        \item Calcula a média dos tempos de execução para ambas as abordagens.
        
        \item Apresenta os tempos médios de execução.
    \end{itemize}
\end{itemize}

A comparação de desempenho é crucial para determinar a abordagem mais eficiente para tarefas concorrentes em sistemas operacionais. Este código fornece uma estrutura para conduzir tal comparação, medindo o tempo médio de execução usando `fork` e threads em várias simulações.

A escolha entre `fork` e threads depende das necessidades específicas de um sistema e dos recursos disponíveis. A análise dos resultados desempenha um papel fundamental na determinação da abordagem mais adequada.


Neste experimento, o código foi projetado para medir e comparar o desempenho de duas abordagens de concorrência em um contexto prático. Os resultados podem ser usados para tomar decisões informadas sobre o uso de `fork` ou threads com base nas demandas do sistema.

A execução de benchmarks é uma prática valiosa para garantir que sistemas e aplicativos atendam aos requisitos de eficiência e desempenho, contribuindo para a otimização e melhoria contínua.



\chapter{Conclusão}
\label{conclusao}





\postextual

\bibliography{bibliografia}

\cite{tanenbaum2010sistemas}

\end{document}
